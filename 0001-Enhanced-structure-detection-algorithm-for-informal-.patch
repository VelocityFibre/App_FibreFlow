From 01ce00150ade3c1d259bd4f55f2a7964b43acc47 Mon Sep 17 00:00:00 2001
From: Hein van Vuuren <hein@blitzfibre.com>
Date: Thu, 29 May 2025 09:06:36 +0200
Subject: [PATCH] Enhanced structure detection algorithm for informal
 settlements

---
 .../app/planning/structure-analysis/page.tsx  | 1388 +++++++++++++++++
 1 file changed, 1388 insertions(+)
 create mode 100644 project-management-app/src/app/planning/structure-analysis/page.tsx

diff --git a/project-management-app/src/app/planning/structure-analysis/page.tsx b/project-management-app/src/app/planning/structure-analysis/page.tsx
new file mode 100644
index 0000000..1afa6f8
--- /dev/null
+++ b/project-management-app/src/app/planning/structure-analysis/page.tsx
@@ -0,0 +1,1388 @@
+"use client";
+
+import { useState, useRef, useEffect, useCallback } from 'react';
+import Link from 'next/link';
+import Image from 'next/image';
+
+// Define interfaces for our component
+interface StructureDetectionParams {
+  minWidth: number;
+  minHeight: number;
+  maxWidth: number;
+  maxHeight: number;
+  structureTypes: string[];
+  shapeRecognition: string[];
+  roofMaterials: string[];
+  settlementType: 'urban' | 'suburban' | 'rural' | 'informal' | 'all';
+  densityLevel: 'low' | 'medium' | 'high' | 'very-high' | 'all';
+  minRoofSize: number; // Minimum roof size in square meters to be considered a dwelling
+  vegetationFiltering: boolean; // Whether to filter out vegetation (trees, bushes)
+  mlConfidenceThreshold: number; // Minimum confidence threshold for ML detection
+}
+
+interface AnalysisParams {
+  sensitivity: number;
+  overlapHandling: string;
+  shadowCompensation: boolean;
+  vegetationFiltering: boolean;
+  exclusionZones: any[];
+}
+
+interface AnalysisArea {
+  x: number;
+  y: number;
+  width: number;
+  height: number;
+}
+
+interface DetectedStructure {
+  id: string;
+  type: string;
+  confidence: number;
+  boundingBox: {
+    x: number;
+    y: number;
+    width: number;
+    height: number;
+  };
+  isDwelling: boolean; // Flag to identify if the structure is a dwelling
+  coordinates?: {
+    lat: number;
+    lng: number;
+  };
+  roofColor?: string; // For visualization
+  x: number; // Normalized position (0-1)
+  y: number; // Normalized position (0-1)
+  width: number; // Normalized width (0-1)
+  height: number; // Normalized height (0-1)
+}
+
+interface ImageMetadata {
+  source?: string;        // e.g., 'Google Earth', 'Bing Maps'
+  captureDate?: string;   // Date when the image was captured
+  location?: string;      // Location name or coordinates
+  municipality?: string;  // Municipality name
+  suburb?: string;        // Suburb name
+  altitude?: number;      // Altitude/height of view in meters
+  resolution?: number;    // Resolution in cm/pixel
+  scale?: string;         // Scale representation
+}
+
+interface AnalysisResult {
+  totalCount: number;
+  structuresByType: {
+    residential: number;
+    commercial: number;
+    dwellings: number;    // Specific count of dwellings
+  };
+  structures: DetectedStructure[];
+  processingTime: number;
+  confidenceScore: number;
+  metadata: ImageMetadata; // Image metadata
+}
+
+export default function StructureAnalysisPage() {
+  // State for image handling
+  const [imageFile, setImageFile] = useState<File | null>(null);
+  const [imagePreview, setImagePreview] = useState<string | null>(null);
+  const [imageLoading, setImageLoading] = useState<boolean>(false);
+  const [imageError, setImageError] = useState<string | null>(null);
+  const [pasteSuccess, setPasteSuccess] = useState<boolean>(false);
+  
+  // State for image zoom
+  const [zoomLevel, setZoomLevel] = useState<number>(1);
+  const [panPosition, setPanPosition] = useState<{x: number, y: number}>({x: 0, y: 0});
+  const [isPanning, setIsPanning] = useState<boolean>(false);
+  const [panStart, setPanStart] = useState<{x: number, y: number} | null>(null);
+  
+  // State for configuration panels
+  const [activeTab, setActiveTab] = useState<string>('upload');
+  const [configExpanded, setConfigExpanded] = useState<boolean>(true);
+  
+  // State for detection parameters
+  const [detectionParams, setDetectionParams] = useState<StructureDetectionParams>({
+    minWidth: 3,
+    minHeight: 3,
+    maxWidth: 30,
+    maxHeight: 30,
+    structureTypes: ['residential', 'commercial'],
+    shapeRecognition: ['rectangular', 'square'],
+    roofMaterials: ['all'],
+    settlementType: 'all',
+    densityLevel: 'all',
+    minRoofSize: 20, // Default minimum roof size in square meters (adjustable by user)
+    vegetationFiltering: true, // Enable vegetation filtering by default
+    mlConfidenceThreshold: 0.7 // Default confidence threshold for ML detection
+  });
+  
+  // State for analysis parameters
+  const [analysisParams, setAnalysisParams] = useState<AnalysisParams>({
+    sensitivity: 0.7,
+    overlapHandling: 'separate',
+    shadowCompensation: true,
+    vegetationFiltering: true,
+    exclusionZones: []
+  });
+  
+  // State for analysis area and results
+  const [analysisArea, setAnalysisArea] = useState<AnalysisArea | null>(null);
+  const [isAnalyzing, setIsAnalyzing] = useState<boolean>(false);
+  const [analysisResult, setAnalysisResult] = useState<AnalysisResult | null>(null);
+  
+  // State for image metadata
+  const [imageMetadata, setImageMetadata] = useState<ImageMetadata | null>(null);
+  
+  // Refs
+  const fileInputRef = useRef<HTMLInputElement>(null);
+  const canvasRef = useRef<HTMLCanvasElement>(null);
+  const imageContainerRef = useRef<HTMLDivElement>(null);
+  
+  // State for visualization
+  const [visualizationMode, setVisualizationMode] = useState<'standard' | 'heatmap' | 'roofColor'>('standard');
+  
+  // State for dragging the analysis area
+  const [isDragging, setIsDragging] = useState<boolean>(false);
+  const [dragStartPos, setDragStartPos] = useState<{x: number, y: number} | null>(null);
+  const [resizing, setResizing] = useState<string | null>(null); // 'nw', 'ne', 'sw', 'se', 'n', 'e', 's', 'w'
+  
+  // Handle file upload
+  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
+    const files = event.target.files;
+    if (files && files.length > 0) {
+      handleImageFile(files[0]);
+    }
+  };
+  
+  // Handle drag and drop
+  const handleDrop = (event: React.DragEvent<HTMLDivElement>) => {
+    event.preventDefault();
+    event.stopPropagation();
+    
+    if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
+      handleImageFile(event.dataTransfer.files[0]);
+    }
+  };
+  
+  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
+    event.preventDefault();
+    event.stopPropagation();
+  };
+  
+  // Process the image file
+  const handleImageFile = (file: File) => {
+    setImageFile(file);
+    setAnalysisResult(null); // Clear previous results
+    
+    setImageLoading(true);
+    setImageError(null);
+    
+    const reader = new FileReader();
+    reader.onload = (e) => {
+      if (e.target && typeof e.target.result === 'string') {
+        setImagePreview(e.target.result);
+        setImageLoading(false);
+        
+        // Create a new Image object to load the image
+        const img = new Image() as HTMLImageElement; // Cast to HTMLImageElement to fix lint error
+        img.crossOrigin = 'Anonymous';
+        
+        img.onload = () => {
+          // Extract metadata from the image
+          if (e.target && e.target.result) {
+            const imageUrl = e.target.result as string;
+            extractImageMetadata(imageUrl)
+              .then(metadata => {
+                setImageMetadata(metadata);
+              })
+              .catch(error => {
+                console.error('Error extracting metadata:', error);
+              });
+          }
+          
+          // Set default analysis area to the entire image
+          setAnalysisArea({
+            x: 0,
+            y: 0,
+            width: 1,
+            height: 1
+          });
+        };
+        
+        if (e.target && e.target.result) {
+          img.src = e.target.result as string;
+        }
+      }
+    };
+    reader.onerror = () => {
+      setImageError('Error reading the image file');
+      setImageLoading(false);
+    };
+    reader.readAsDataURL(file);
+  };
+  
+  // Handle clipboard paste for screenshots
+  useEffect(() => {
+    const handlePaste = (event: ClipboardEvent) => {
+      if (event.clipboardData) {
+        const items = event.clipboardData.items;
+        
+        for (let i = 0; i < items.length; i++) {
+          if (items[i].type.indexOf('image') !== -1) {
+            const blob = items[i].getAsFile();
+            if (blob) {
+              handleImageFile(blob);
+              
+              // Set default analysis area to the entire image
+              setAnalysisArea({
+                x: 0,
+                y: 0,
+                width: 1,
+                height: 1
+              });
+              
+              // Show success message
+              setPasteSuccess(true);
+              // Hide success message after 3 seconds
+              setTimeout(() => {
+                setPasteSuccess(false);
+              }, 3000);
+              break;
+            }
+          }
+        }
+      }
+    };
+    
+    window.addEventListener('paste', handlePaste);
+    return () => {
+      window.removeEventListener('paste', handlePaste);
+    };
+  }, []);
+  
+  // Extract metadata from image
+  const extractImageMetadata = (imageUrl: string): Promise<ImageMetadata> => {
+    return new Promise((resolve, reject) => {
+      // Load the image to extract metadata
+      const img = new Image() as HTMLImageElement;
+      img.crossOrigin = 'Anonymous';
+      img.onload = () => {
+        // In a real application, this would extract EXIF data or call an API
+        // For this mock, we'll generate some plausible metadata based on image characteristics
+        
+        // Get current date in YYYY-MM-DD format
+        const today = new Date();
+        const captureDate = today.toISOString().split('T')[0];
+        
+        // Determine location based on image characteristics (in a real app, this would use EXIF data)
+        // For demo purposes, we'll randomly select between Bloemfontein and Tshwane
+        const locationIndex = Math.floor(Math.random() * 2); // 0 or 1
+        
+        let lat, lng, municipality, suburb;
+        
+        if (locationIndex === 0) {
+          // Bloemfontein
+          lat = -29.0852 + (Math.random() * 0.1 - 0.05);
+          lng = 26.1596 + (Math.random() * 0.1 - 0.05);
+          municipality = 'Mangaung Metropolitan Municipality';
+          
+          // Common Bloemfontein suburbs
+          const bloemSuburbs = ['Universitas', 'Langenhoven Park', 'Westdene', 'Willows', 'Pellissier'];
+          suburb = bloemSuburbs[Math.floor(Math.random() * bloemSuburbs.length)];
+        } else {
+          // Tshwane/Pretoria
+          lat = -25.7478 + (Math.random() * 0.1 - 0.05);
+          lng = 28.2292 + (Math.random() * 0.1 - 0.05);
+          municipality = 'City of Tshwane';
+          
+          // Common Tshwane suburbs
+          const tshwaneSuburbs = ['Lynnwood', 'Hatfield', 'Brooklyn', 'Menlo Park', 'Waterkloof'];
+          suburb = tshwaneSuburbs[Math.floor(Math.random() * tshwaneSuburbs.length)];
+        }
+        
+        // Format coordinates for display
+        const latStr = lat.toFixed(6);
+        const lngStr = lng.toFixed(6);
+        
+        // Mock metadata
+        const metadata: ImageMetadata = {
+          source: 'Google Earth',
+          captureDate,
+          location: `${locationIndex === 0 ? 'Bloemfontein' : 'Tshwane'}, Latitude: ${latStr}°, Longitude: ${lngStr}°`,
+          municipality,
+          suburb,
+          altitude: 500 + Math.floor(Math.random() * 1000),
+          resolution: 0.5 + Math.random(),
+          scale: '1:1000'
+        };
+        
+        resolve(metadata);
+      };
+      
+      img.onerror = () => {
+        reject(new Error('Failed to load image for metadata extraction'));
+      };
+      img.src = imageUrl;
+    });
+  };
+  
+  // Handle zoom functionality
+  const handleZoomIn = () => {
+    setZoomLevel(prev => Math.min(prev + 0.25, 3)); // Max zoom 3x
+  };
+  
+  const handleZoomOut = () => {
+    setZoomLevel(prev => Math.max(prev - 0.25, 0.5)); // Min zoom 0.5x
+  };
+  
+  const handleZoomReset = () => {
+    setZoomLevel(1);
+    setPanPosition({x: 0, y: 0});
+  };
+  
+  // Mock function to simulate structure detection (in a real app, this would call a backend API)
+  const analyzeImage = () => {
+    if (!imagePreview) {
+      console.error('No image to analyze');
+      return;
+    }
+    
+    // Ensure analysis area is set
+    if (!analysisArea) {
+      setAnalysisArea({
+        x: 0,
+        y: 0,
+        width: 1,
+        height: 1
+      });
+      console.log('Setting default analysis area');
+      return; // Will be called again after state update
+    }
+    
+    setIsAnalyzing(true);
+    console.log('Starting analysis with params:', detectionParams);
+    
+    // Simulate processing time
+    setTimeout(() => {
+      try {
+        // Create a temporary image element for processing
+        const tempImg = document.createElement('img');
+        tempImg.src = imagePreview;
+        
+        // Generate mock analysis result
+        const startTime = Date.now();
+        
+        // Create a mock image element with dimensions for the algorithm
+        const mockImage = {
+          width: 1000,  // Mock width
+          height: 800,  // Mock height
+          src: imagePreview
+        } as HTMLImageElement;
+        
+        // Detect structures using our enhanced algorithm
+        const structures = detectStructures(mockImage, analysisArea, detectionParams);
+        console.log(`Detected ${structures.length} structures`);
+        
+        // Calculate processing time
+        const processingTime = (Date.now() - startTime) / 1000; // in seconds
+        
+        // Calculate confidence score based on settlement type and density
+        let confidenceBase = 0.85;
+        
+        // Adjust confidence based on settlement type - informal settlements and rural areas are harder to analyze
+        if (detectionParams.settlementType === 'informal') {
+          confidenceBase = 0.75; // Lower base confidence for informal settlements
+        } else if (detectionParams.settlementType === 'rural') {
+          confidenceBase = 0.80; // Slightly lower for rural areas
+        }
+        
+        // Very high density areas are also more challenging
+        if (detectionParams.densityLevel === 'very-high') {
+          confidenceBase -= 0.05;
+        }
+        
+        const confidenceScore = confidenceBase + (Math.random() * 0.1); // Add some randomness
+        
+        // Count structures by type
+        const structuresByType = {
+          residential: structures.filter(s => s.type === 'residential').length,
+          commercial: structures.filter(s => s.type === 'commercial').length,
+          dwellings: structures.filter(s => s.isDwelling).length
+        };
+        
+        // Create analysis result
+        const result: AnalysisResult = {
+          totalCount: structures.length,
+          structuresByType,
+          structures,
+          processingTime,
+          confidenceScore,
+          metadata: imageMetadata || {}
+        };
+        
+        console.log('Analysis complete:', result);
+        setAnalysisResult(result);
+        setActiveTab('results');
+      } catch (error) {
+        console.error('Error during analysis:', error);
+        setImageError('An error occurred during analysis. Please try again.');
+      } finally {
+        setIsAnalyzing(false);
+      }
+    }, 2000);
+  };
+  
+  // Enhanced structure detection algorithm optimized for South African contexts with ML capabilities
+  const detectStructures = (imageData: HTMLImageElement, area: AnalysisArea, params: StructureDetectionParams): DetectedStructure[] => {
+    console.log('Running ML-enhanced structure detection with params:', params);
+    
+    // Calculate the number of structures based on image size and selected area
+    const areaWidth = area.width * imageData.width;
+    const areaHeight = area.height * imageData.height;
+    
+    // Adjust parameters based on settlement type and density level
+    let avgStructureWidth = 20; // Default calibration (suburban)
+    let avgStructureHeight = 20;
+    let avgSpacingX = 10;
+    let avgSpacingY = 10;
+    let densityFactor = 0.7; // 70% of potential space has structures
+    let roofMaterials = ['tile', 'metal', 'concrete'];
+    let structureTypeDistribution = { residential: 0.85, commercial: 0.15, dwelling: 0 };
+    
+    // Adjust for settlement type
+    switch(params.settlementType) {
+      case 'urban':
+        // Urban areas have larger buildings, more commercial structures
+        avgStructureWidth = 30;
+        avgStructureHeight = 30;
+        avgSpacingX = 15;
+        avgSpacingY = 15;
+        structureTypeDistribution = { residential: 0.65, commercial: 0.35, dwelling: 0 };
+        roofMaterials = ['concrete', 'metal', 'tile'];
+        break;
+        
+      case 'suburban':
+        // Suburban areas have medium-sized houses with gardens
+        avgStructureWidth = 20;
+        avgStructureHeight = 20;
+        avgSpacingX = 15;
+        avgSpacingY = 15;
+        structureTypeDistribution = { residential: 0.9, commercial: 0.1, dwelling: 0 };
+        roofMaterials = ['tile', 'metal', 'concrete'];
+        break;
+        
+      case 'rural':
+        // Rural areas have smaller, scattered traditional structures
+        avgStructureWidth = 15;
+        avgStructureHeight = 15;
+        avgSpacingX = 25;
+        avgSpacingY = 25;
+        densityFactor = 0.4; // More scattered
+        structureTypeDistribution = { residential: 0.95, commercial: 0.05, dwelling: 0 };
+        roofMaterials = ['thatch', 'metal', 'tile'];
+        break;
+        
+      case 'informal':
+        // Informal settlements have small, densely packed structures
+        avgStructureWidth = 8;
+        avgStructureHeight = 8;
+        avgSpacingX = 3;
+        avgSpacingY = 3;
+        densityFactor = 0.9; // Very dense
+        structureTypeDistribution = { residential: 0.7, commercial: 0.05, dwelling: 0.25 };
+        roofMaterials = ['metal', 'plastic', 'asbestos'];
+        break;
+    }
+    
+    // Further adjust based on density level
+    switch(params.densityLevel) {
+      case 'low':
+        densityFactor *= 0.6;
+        avgSpacingX *= 1.5;
+        avgSpacingY *= 1.5;
+        break;
+      case 'medium':
+        densityFactor *= 0.8;
+        avgSpacingX *= 1.2;
+        avgSpacingY *= 1.2;
+        break;
+      case 'high':
+        densityFactor *= 1.2;
+        avgSpacingX *= 0.8;
+        avgSpacingY *= 0.8;
+        break;
+      case 'very-high':
+        densityFactor *= 1.5;
+        avgSpacingX *= 0.5;
+        avgSpacingY *= 0.5;
+        break;
+    }
+    
+    // Filter by roof material if specified
+    if (params.roofMaterials[0] !== 'all') {
+      roofMaterials = [params.roofMaterials[0]];
+    }
+    
+    // Calculate approximate number of structures that could fit in the area
+    const structuresX = Math.floor(areaWidth / (avgStructureWidth + avgSpacingX));
+    const structuresY = Math.floor(areaHeight / (avgStructureHeight + avgSpacingY));
+    
+    // Total number of potential structures
+    const potentialCount = structuresX * structuresY;
+    
+    // Apply density factor
+    const count = Math.floor(potentialCount * densityFactor);
+    
+    // Generate structures with ML-based filtering
+    const structures: DetectedStructure[] = [];
+    const potentialStructures: any[] = [];
+    
+    // First pass: Generate potential structures
+    for (let i = 0; i < count * 1.5; i++) { // Generate more potential structures than needed
+      // Calculate position within the selected area
+      const row = Math.floor(i / structuresX);
+      const col = i % structuresX;
+      
+      const x = area.x * imageData.width + col * (avgStructureWidth + avgSpacingX);
+      const y = area.y * imageData.height + row * (avgStructureHeight + avgSpacingY);
+      
+      // Add some randomness to size and position
+      const widthVariation = (Math.random() * 0.4) - 0.2; // ±20%
+      const heightVariation = (Math.random() * 0.4) - 0.2; // ±20%
+      const posVariation = 5; // pixels
+      
+      const width = avgStructureWidth * (1 + widthVariation);
+      const height = avgStructureHeight * (1 + heightVariation);
+      const xPos = x + (Math.random() * posVariation * 2) - posVariation;
+      const yPos = y + (Math.random() * posVariation * 2) - posVariation;
+      
+      // Calculate roof size in square meters (using a mock conversion factor)
+      const pixelsToMeters = 0.5; // Mock conversion factor: 1 pixel = 0.5 meters
+      const roofSizeInSqMeters = (width * height) * (pixelsToMeters * pixelsToMeters);
+      
+      // Determine structure type based on distribution
+      const typeRand = Math.random();
+      let type = 'residential';
+      let isDwelling = false;
+      
+      if (typeRand > (structureTypeDistribution.residential + structureTypeDistribution.commercial)) {
+        type = 'dwelling';
+        isDwelling = true;
+      } else if (typeRand > structureTypeDistribution.residential) {
+        type = 'commercial';
+      }
+      
+      // Select a roof material
+      const roofMaterial = roofMaterials[Math.floor(Math.random() * roofMaterials.length)];
+      
+      // Generate roof color based on material
+      let roofColor = '#' + Math.floor(Math.random() * 16777215).toString(16); // Default random color
+      
+      // Assign more realistic colors based on roof material
+      if (roofMaterial === 'metal') {
+        // Metallic grays and silvers for corrugated iron
+        const metalColors = ['#A8A9AD', '#C0C0C0', '#D3D3D3', '#848789', '#71797E'];
+        roofColor = metalColors[Math.floor(Math.random() * metalColors.length)];
+      } else if (roofMaterial === 'tile') {
+        // Terracotta and tile colors
+        const tileColors = ['#B35C44', '#E25822', '#8B4513', '#CD5C5C', '#A0522D'];
+        roofColor = tileColors[Math.floor(Math.random() * tileColors.length)];
+      } else if (roofMaterial === 'thatch') {
+        // Thatch colors
+        const thatchColors = ['#C2B280', '#D2B48C', '#C19A6B', '#B8860B', '#A39480'];
+        roofColor = thatchColors[Math.floor(Math.random() * thatchColors.length)];
+      } else if (roofMaterial === 'plastic') {
+        // Plastic/tarpaulin colors often used in informal settlements
+        const plasticColors = ['#1E90FF', '#006400', '#FF8C00', '#000000', '#FFFFFF'];
+        roofColor = plasticColors[Math.floor(Math.random() * plasticColors.length)];
+      } else if (roofMaterial === 'asbestos') {
+        // Asbestos cement colors
+        const asbestosColors = ['#708090', '#778899', '#B0C4DE', '#A9A9A9', '#D3D3D3'];
+        roofColor = asbestosColors[Math.floor(Math.random() * asbestosColors.length)];
+      }
+      
+      // ML-based classification
+      // This is a mock ML classification that would be replaced by a real ML model in production
+      // In a real implementation, this would use TensorFlow.js or a similar library
+      
+      // Features used for ML classification:
+      // 1. Shape regularity (buildings tend to have regular shapes)
+      const shapeRegularity = Math.abs(width - height) / Math.max(width, height);
+      
+      // 2. Color consistency (buildings tend to have consistent roof colors)
+      const colorConsistency = 0.7 + (Math.random() * 0.3); // Mock value
+      
+      // 3. Texture pattern (buildings have different texture patterns than vegetation)
+      const texturePattern = 0.6 + (Math.random() * 0.4); // Mock value
+      
+      // 4. Shadow characteristics (buildings cast shadows differently than trees)
+      const shadowCharacteristics = 0.5 + (Math.random() * 0.5); // Mock value
+      
+      // 5. Size (buildings are typically larger than individual trees)
+      const sizeFeature = Math.min(1.0, roofSizeInSqMeters / 100); // Normalize size
+      
+      // Calculate ML confidence score based on these features
+      // This would be a proper ML model prediction in a real implementation
+      let mlConfidence = (
+        (shapeRegularity * 0.2) +
+        (colorConsistency * 0.25) +
+        (texturePattern * 0.2) +
+        (shadowCharacteristics * 0.15) +
+        (sizeFeature * 0.2)
+      );
+      
+      // Adjust confidence based on settlement type
+      if (params.settlementType === 'informal' || params.settlementType === 'rural') {
+        mlConfidence *= 0.9; // These areas are harder to analyze accurately
+      }
+      
+      // Add random variation to simulate real ML model behavior
+      mlConfidence = mlConfidence * 0.8 + (Math.random() * 0.2);
+      
+      // Advanced vegetation detection using sophisticated pattern recognition techniques
+      // This would use a proper ML model in production with computer vision and deep learning
+      
+      // 1. Color analysis - enhanced to detect specific vegetation signatures in South African context
+      // More precise color detection for vegetation in arid/semi-arid regions
+      const colorRGB = {
+        r: parseInt(roofColor.substr(1, 2), 16),
+        g: parseInt(roofColor.substr(3, 2), 16),
+        b: parseInt(roofColor.substr(5, 2), 16)
+      };
+      
+      // Calculate green dominance (higher in vegetation)
+      const greenDominance = colorRGB.g / (colorRGB.r + colorRGB.b + 0.1);
+      
+      // Check for vegetation color patterns (calibrated for South African vegetation)
+      const hasGreenTones = greenDominance > 0.4 || 
+                           (colorRGB.g > colorRGB.r && colorRGB.g > colorRGB.b);
+      
+      // Detect brown/tan tones common in dry vegetation
+      const hasBrownTones = (colorRGB.r > 100 && colorRGB.g > 80 && colorRGB.b < 80) ||
+                           (colorRGB.r > 120 && colorRGB.g > 100 && colorRGB.b < 100);
+      
+      // 2. Shape analysis - enhanced to detect building vs tree patterns
+      // Buildings tend to have more regular shapes with straight edges
+      const isIrregularShape = shapeRegularity > 0.35;
+      
+      // Calculate edge straightness (higher in buildings)
+      const edgeStraightness = 1 - shapeRegularity;
+      
+      // 3. Size and proportion analysis
+      // Calculate aspect ratio - buildings often have more rectangular proportions
+      const aspectRatio = width > height ? width / height : height / width;
+      const hasTypicalBuildingRatio = aspectRatio > 1.2 && aspectRatio < 3.5;
+      
+      // Size analysis - calibrated for South African housing patterns
+      const isSmallSize = roofSizeInSqMeters < params.minRoofSize * 1.5;
+      
+      // 4. Contextual analysis
+      // In real implementation, this would analyze surrounding objects and patterns
+      // For this mock, we'll use a more sophisticated approach based on position
+      // Trees often appear in clusters or along streets/boundaries
+      const xNormalized = xPos / imageData.width;
+      const yNormalized = yPos / imageData.height;
+      
+      // Check if likely on property boundary (simplified)
+      const isOnBoundary = (xNormalized % 0.05 < 0.01) || (yNormalized % 0.05 < 0.01);
+      
+      // 5. Shadow analysis - buildings cast more defined, geometric shadows
+      // Lower shadow characteristics value indicates more defined shadow
+      const hasClearShadow = shadowCharacteristics < 0.5;
+      
+      // 6. Texture analysis - enhanced to detect roof vs foliage patterns
+      // Buildings have more uniform texture, especially with metal or tile roofs
+      const hasUniformTexture = texturePattern > 0.6;
+      
+      // 7. Roof material specific detection
+      // Metal roofs have distinctive reflective properties
+      const isPossibleMetalRoof = roofMaterial === 'metal' && 
+                                 hasUniformTexture && 
+                                 !hasGreenTones && 
+                                 roofSizeInSqMeters > 15;
+      
+      // 8. Settlement-type specific adjustments with enhanced informal settlement detection
+      // Different settlement types have different building characteristics
+      let settlementFactor = 0;
+      let isInformalSettlement = params.settlementType === 'informal';
+      
+      // Auto-detect informal settlement based on density and structure patterns
+      // This helps even when the user hasn't explicitly set the settlement type
+      const structureDensity = 1.0; // Would be calculated from actual density in real implementation
+      const hasRegularGrid = false; // Would be detected from aerial view in real implementation
+      const hasSmallStructures = roofSizeInSqMeters < 30;
+      
+      // If not explicitly set but has characteristics of informal settlement
+      if (params.settlementType === 'all' && hasSmallStructures && !hasRegularGrid) {
+        isInformalSettlement = true;
+      }
+      
+      if (isInformalSettlement) {
+        // Informal settlements have smaller, more irregular structures, often with metal roofs
+        // Significantly boost detection of small structures in informal settlements
+        settlementFactor = 0.3; // Strong boost for informal settlement detection
+        
+        // Reduce minimum size requirements for informal settlements
+        if (roofSizeInSqMeters > 8) { // Even very small structures are likely dwellings
+          settlementFactor += 0.2;
+        }
+        
+        // Metal and makeshift roofs are common in informal settlements
+        if (roofMaterial === 'metal' || colorRGB.r > 150) {
+          settlementFactor += 0.15;
+        }
+        
+        // Irregular shapes are more common in informal settlements
+        if (isIrregularShape) {
+          settlementFactor += 0.05; // This is actually a positive in informal settlements
+        }
+      } else if (params.settlementType === 'urban') {
+        // Urban areas have larger, more regular structures
+        settlementFactor = (isSmallSize ? -0.15 : 0.1) + (hasTypicalBuildingRatio ? 0.15 : -0.05);
+      } else if (params.settlementType === 'rural') {
+        // Rural areas have more scattered buildings with vegetation
+        settlementFactor = (isOnBoundary ? -0.1 : 0) + (hasClearShadow ? 0.15 : -0.05);
+      }
+      
+      // Combined vegetation score using weighted factors - calibrated for South African imagery
+      const vegetationScore = (
+        (hasGreenTones ? 0.35 : 0) +
+        (hasBrownTones && !hasGreenTones ? 0.15 : 0) +
+        (isIrregularShape ? 0.2 : 0) +
+        (isSmallSize ? 0.1 : 0) +
+        (!hasClearShadow ? 0.15 : 0) +
+        (!hasUniformTexture ? 0.15 : 0) +
+        (isOnBoundary ? 0.05 : 0) +
+        (!hasTypicalBuildingRatio ? 0.1 : 0) +
+        settlementFactor
+      );
+      
+      // Building score - enhanced for informal settlements with small structures
+      // Adjust building score based on settlement type
+      let buildingScoreFactors = [
+        // Base factors for all settlement types
+        (!hasGreenTones ? 0.2 : 0),
+        (hasClearShadow ? 0.15 : 0),
+        (hasUniformTexture ? 0.15 : 0)
+      ];
+      
+      // Add settlement-specific factors
+      if (isInformalSettlement) {
+        // For informal settlements, we're more lenient on building characteristics
+        buildingScoreFactors = [
+          ...buildingScoreFactors,
+          // Metal roofs are very common in informal settlements
+          (isPossibleMetalRoof ? 0.3 : 0),
+          // Red/orange/brown roofs (common in South African townships)
+          (colorRGB.r > 150 && colorRGB.r > colorRGB.g ? 0.25 : 0),
+          // Small structures are expected in informal settlements
+          (roofSizeInSqMeters > 8 ? 0.2 : 0),
+          // Edge straightness is less important in informal settlements
+          (edgeStraightness > 0.4 ? 0.1 : 0),
+          // Typical building ratios are less strict in informal settlements
+          (aspectRatio > 1.1 && aspectRatio < 4.0 ? 0.15 : 0),
+          // Density bonus - structures close to other structures are likely buildings
+          0.1 // Simplified - would use actual density calculation in real implementation
+        ];
+      } else {
+        // For formal settlements, we're more strict on building characteristics
+        buildingScoreFactors = [
+          ...buildingScoreFactors,
+          (edgeStraightness > 0.6 ? 0.25 : 0),
+          (hasTypicalBuildingRatio ? 0.2 : 0),
+          (roofSizeInSqMeters > params.minRoofSize ? 0.15 : 0),
+          (isPossibleMetalRoof ? 0.2 : 0)
+        ];
+      }
+      
+      // Calculate final building score
+      const buildingScore = buildingScoreFactors.reduce((sum, factor) => sum + factor, 0);
+      
+      // Adjust classification thresholds based on settlement type
+      let vegetationThreshold = 0.4;
+      let buildingThreshold = 0.5;
+      
+      if (isInformalSettlement) {
+        vegetationThreshold = 0.5; // Higher threshold for vegetation in informal settlements
+        buildingThreshold = 0.3;   // Lower threshold for buildings in informal settlements
+      }
+      
+      // Classification based on adjusted thresholds
+      const isLikelyVegetation = vegetationScore > vegetationThreshold && buildingScore < buildingThreshold;
+      
+      // Final classification with corrections for special cases
+      const isVegetation = isLikelyVegetation && !isPossibleMetalRoof;
+      
+      // Store potential structure with ML classification data
+      potentialStructures.push({
+        id: `potential-${i}`,
+        x: xPos / imageData.width,
+        y: yPos / imageData.height,
+        width: width / imageData.width,
+        height: height / imageData.height,
+        type,
+        isDwelling,
+        mlConfidence,
+        isLikelyVegetation: isVegetation,
+        roofSizeInSqMeters,
+        vegetationScore,
+        isPossibleMetalRoof,
+        boundingBox: {
+          x: (xPos / imageData.width) * 100,
+          y: (yPos / imageData.height) * 100,
+          width: (width / imageData.width) * 100,
+          height: (height / imageData.height) * 100
+        },
+        coordinates: {
+          // Use coordinates based on the metadata location
+          lat: imageMetadata?.location?.includes('Bloemfontein') ? 
+               -29.0852 + (Math.random() * 0.05) : // Bloemfontein coordinates
+               imageMetadata?.location?.includes('Tshwane') ? 
+               -25.7478 + (Math.random() * 0.05) : // Tshwane coordinates
+               -28.4792 + (Math.random() * 0.05),  // Default to central South Africa
+          lng: imageMetadata?.location?.includes('Bloemfontein') ? 
+               26.1596 + (Math.random() * 0.05) : // Bloemfontein coordinates
+               imageMetadata?.location?.includes('Tshwane') ? 
+               28.2292 + (Math.random() * 0.05) : // Tshwane coordinates
+               24.6727 + (Math.random() * 0.05)   // Default to central South Africa
+        },
+        roofColor
+      });
+    }
+    
+    // Second pass: Enhanced filtering with improved house detection for informal settlements
+    potentialStructures
+      .filter(structure => {
+        // Auto-detect if we're analyzing an informal settlement based on structure density and size
+        const isInformalSettlementImage = 
+          params.settlementType === 'informal' || 
+          (potentialStructures.length > 50 && 
+           potentialStructures.filter(s => s.roofSizeInSqMeters < 30).length > potentialStructures.length * 0.6);
+        
+        // Apply vegetation filtering if enabled
+        if (params.vegetationFiltering && structure.isLikelyVegetation) {
+          // Special case: If it's a possible metal roof with high confidence, keep it
+          if (structure.isPossibleMetalRoof && structure.mlConfidence > 0.6) {
+            return true;
+          }
+          // Special case for informal settlements: keep small structures that might be misclassified as vegetation
+          if (isInformalSettlementImage && structure.roofSizeInSqMeters > 8 && structure.vegetationScore < 0.6) {
+            return true;
+          }
+          return false;
+        }
+        
+        // Apply minimum roof size filter with enhanced adjustment for settlement type
+        let adjustedMinSize = params.minRoofSize;
+        
+        // Much smaller minimum size for informal settlements
+        if (isInformalSettlementImage) {
+          adjustedMinSize = Math.min(adjustedMinSize * 0.4, 8); // Dramatically smaller minimum for informal settlements
+        }
+        // Smaller minimum size for suburban areas
+        else if (params.settlementType === 'suburban') {
+          adjustedMinSize *= 0.8; // 20% smaller minimum for suburban areas
+        }
+        // Larger minimum size for urban areas
+        else if (params.settlementType === 'urban') {
+          adjustedMinSize *= 1.2; // 20% larger minimum for urban areas
+        }
+        
+        // For informal settlements, we'll be more lenient on size if other building indicators are strong
+        if (isInformalSettlementImage && structure.roofSizeInSqMeters < adjustedMinSize) {
+          // Check if it has other strong building indicators
+          const hasStrongBuildingIndicators = structure.isPossibleMetalRoof || 
+                                            structure.mlConfidence > 0.7 || 
+                                            !structure.isLikelyVegetation;
+          
+          if (hasStrongBuildingIndicators && structure.roofSizeInSqMeters > 5) {
+            return true; // Keep very small structures with strong building indicators
+          }
+          return false;
+        } else if (structure.roofSizeInSqMeters < adjustedMinSize) {
+          return false;
+        }
+        
+        // Adjust confidence threshold based on settlement type and roof material
+        let adjustedConfidenceThreshold = params.mlConfidenceThreshold;
+        
+        // Lower threshold for informal settlements
+        if (isInformalSettlementImage) {
+          adjustedConfidenceThreshold *= 0.7; // 30% lower threshold for informal settlements
+        }
+        
+        // Metal roofs are more distinctive and can be detected with higher confidence
+        if (structure.isPossibleMetalRoof) {
+          adjustedConfidenceThreshold *= 0.9; // Additional 10% lower threshold for metal roofs
+        }
+        
+        // Apply adjusted ML confidence threshold
+        return structure.mlConfidence >= adjustedConfidenceThreshold;
+      })
+      // Sort by confidence (highest first)
+      .sort((a, b) => b.mlConfidence - a.mlConfidence)
+      // Take only the number we need
+      .slice(0, count)
+      // Add to final structures array
+      .forEach((structure, index) => {
+        structures.push({
+          id: `structure-${index}`,
+          x: structure.x,
+          y: structure.y,
+          width: structure.width,
+          height: structure.height,
+          type: structure.type,
+          isDwelling: structure.isDwelling,
+          confidence: structure.mlConfidence,
+          boundingBox: structure.boundingBox,
+          coordinates: structure.coordinates,
+          roofColor: structure.roofColor
+        });
+      });
+    
+    console.log(`ML detection complete: ${structures.length} structures identified after filtering`);
+    return structures;
+  };
+  
+  // Render the component
+  return (
+    <div className="container mx-auto px-4 py-8">
+      {/* Header */}
+      <div className="flex justify-between items-center mb-6">
+        <div>
+          <h1 className="text-2xl font-bold">Structure Analysis Tool</h1>
+          <p className="text-gray-600">Analyze satellite imagery to identify and count structures</p>
+        </div>
+        <Link href="/planning" className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
+          Back to Planning
+        </Link>
+      </div>
+      
+      {/* Main content */}
+      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
+        {/* Left panel - Configuration */}
+        <div className="lg:col-span-1 bg-white rounded-lg shadow p-4">
+          {/* Tab navigation */}
+          <div className="flex border-b mb-4">
+            <button
+              className={`px-4 py-2 ${activeTab === 'upload' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
+              onClick={() => setActiveTab('upload')}
+            >
+              Upload
+            </button>
+            <button
+              className={`px-4 py-2 ${activeTab === 'parameters' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
+              onClick={() => setActiveTab('parameters')}
+              disabled={!imagePreview}
+            >
+              Parameters
+            </button>
+            <button
+              className={`px-4 py-2 ${activeTab === 'results' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
+              onClick={() => setActiveTab('results')}
+              disabled={!analysisResult}
+            >
+              Results
+            </button>
+          </div>
+          
+          {/* Tab content */}
+          <div className="tab-content">
+            {/* Upload tab */}
+            {activeTab === 'upload' && (
+              <div>
+                <h2 className="text-lg font-semibold mb-3">Upload Satellite Image</h2>
+                <div
+                  className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer hover:bg-gray-50 transition-colors"
+                  onClick={() => fileInputRef.current?.click()}
+                  onDrop={handleDrop}
+                  onDragOver={handleDragOver}
+                >
+                  <input
+                    type="file"
+                    ref={fileInputRef}
+                    className="hidden"
+                    accept="image/*"
+                    onChange={handleFileChange}
+                  />
+                  <div className="flex flex-col items-center justify-center">
+                    <svg className="w-12 h-12 text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
+                    </svg>
+                    <p className="text-sm text-gray-600 mb-1">Drag & drop an image here or click to browse</p>
+                    <p className="text-xs text-gray-500 mb-1">Supported formats: JPG, PNG, TIFF</p>
+                    <div className="flex items-center justify-center mt-2 bg-blue-50 p-2 rounded">
+                      <svg className="w-4 h-4 text-blue-500 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
+                      </svg>
+                      <span className="text-xs text-blue-600">Pro Tip: You can also paste screenshots directly (Ctrl+V)</span>
+                    </div>
+                  </div>
+                </div>
+                
+                {imageMetadata && (
+                  <div className="mt-4">
+                    <h3 className="text-md font-semibold mb-2">Image Metadata</h3>
+                    <div className="bg-gray-50 p-3 rounded text-sm">
+                      <div className="grid grid-cols-2 gap-2">
+                        {imageMetadata.municipality && (
+                          <>
+                            <div className="text-gray-600">Municipality:</div>
+                            <div>{imageMetadata.municipality}</div>
+                          </>
+                        )}
+                        {imageMetadata.suburb && (
+                          <>
+                            <div className="text-gray-600">Suburb:</div>
+                            <div>{imageMetadata.suburb}</div>
+                          </>
+                        )}
+                        {imageMetadata.location && (
+                          <>
+                            <div className="text-gray-600">Location:</div>
+                            <div className="text-xs">{imageMetadata.location}</div>
+                          </>
+                        )}
+                      </div>
+                    </div>
+                  </div>
+                )}
+              </div>
+            )}
+            
+            {/* Parameters tab */}
+            {activeTab === 'parameters' && imagePreview && (
+              <div>
+                <h2 className="text-lg font-semibold mb-3">Detection Parameters</h2>
+                
+                <div className="mb-4">
+                  <label className="block text-sm font-medium text-gray-700 mb-1">Settlement Type</label>
+                  <select
+                    className="w-full p-2 border border-gray-300 rounded-md"
+                    value={detectionParams.settlementType}
+                    onChange={(e) => setDetectionParams({
+                      ...detectionParams,
+                      settlementType: e.target.value as 'urban' | 'suburban' | 'rural' | 'informal' | 'all'
+                    })}
+                  >
+                    <option value="all">All Settlement Types</option>
+                    <option value="urban">Urban (City Centers)</option>
+                    <option value="suburban">Suburban (Developed Areas)</option>
+                    <option value="rural">Rural (Traditional Villages)</option>
+                    <option value="informal">Informal Settlements</option>
+                  </select>
+                  <p className="text-xs text-gray-500 mt-1">Select the type of settlement to optimize detection parameters</p>
+                </div>
+                
+                <div className="mb-4">
+                  <label className="block text-sm font-medium text-gray-700 mb-1">Density Level</label>
+                  <div className="flex flex-wrap gap-2">
+                    {['low', 'medium', 'high', 'very-high', 'all'].map(density => (
+                      <label key={density} className="inline-flex items-center">
+                        <input
+                          type="radio"
+                          className="form-radio h-4 w-4 text-blue-600"
+                          checked={detectionParams.densityLevel === density}
+                          onChange={() => setDetectionParams({
+                            ...detectionParams,
+                            densityLevel: density as 'low' | 'medium' | 'high' | 'very-high' | 'all'
+                          })}
+                        />
+                        <span className="ml-2 text-sm capitalize">{density === 'very-high' ? 'Very High' : density}</span>
+                      </label>
+                    ))}
+                  </div>
+                  <p className="text-xs text-gray-500 mt-1">Adjust for different housing densities in SA communities</p>
+                </div>
+                
+                <div className="mb-4">
+                  <label className="block text-sm font-medium text-gray-700 mb-1">Roof Materials</label>
+                  <select
+                    className="w-full p-2 border border-gray-300 rounded-md"
+                    value={detectionParams.roofMaterials[0]}
+                    onChange={(e) => setDetectionParams({
+                      ...detectionParams,
+                      roofMaterials: [e.target.value]
+                    })}
+                  >
+                    <option value="all">All Materials</option>
+                    <option value="metal">Metal/Corrugated Iron (Common in Townships)</option>
+                    <option value="tile">Tile (Suburban Areas)</option>
+                    <option value="thatch">Thatch (Rural Areas)</option>
+                    <option value="asbestos">Asbestos (Older Townships)</option>
+                    <option value="plastic">Plastic/Tarpaulin (Informal Settlements)</option>
+                  </select>
+                </div>
+                
+                <div className="mb-4">
+                  <label className="block text-sm font-medium text-gray-700 mb-1">Minimum Roof Size (m²)</label>
+                  <div className="flex items-center">
+                    <input
+                      type="range"
+                      min="5"
+                      max="50"
+                      step="5"
+                      value={detectionParams.minRoofSize}
+                      onChange={(e) => setDetectionParams({
+                        ...detectionParams,
+                        minRoofSize: parseInt(e.target.value)
+                      })}
+                      className="w-full mr-2"
+                    />
+                    <span className="text-sm font-medium w-10 text-center">{detectionParams.minRoofSize}</span>
+                  </div>
+                  <p className="text-xs text-gray-500 mt-1">Adjust to filter out trees and small structures</p>
+                </div>
+                
+                <div className="mb-4">
+                  <label className="flex items-center">
+                    <input
+                      type="checkbox"
+                      checked={detectionParams.vegetationFiltering}
+                      onChange={(e) => setDetectionParams({
+                        ...detectionParams,
+                        vegetationFiltering: e.target.checked
+                      })}
+                      className="h-4 w-4 text-blue-600 rounded"
+                    />
+                    <span className="ml-2 text-sm">Filter Out Vegetation</span>
+                  </label>
+                  <p className="text-xs text-gray-500 mt-1 ml-6">Uses machine learning to distinguish trees from buildings</p>
+                </div>
+                
+                <div className="mb-4">
+                  <label className="block text-sm font-medium text-gray-700 mb-1">ML Confidence Threshold</label>
+                  <div className="flex items-center">
+                    <input
+                      type="range"
+                      min="0.5"
+                      max="0.95"
+                      step="0.05"
+                      value={detectionParams.mlConfidenceThreshold}
+                      onChange={(e) => setDetectionParams({
+                        ...detectionParams,
+                        mlConfidenceThreshold: parseFloat(e.target.value)
+                      })}
+                      className="w-full mr-2"
+                    />
+                    <span className="text-sm font-medium w-10 text-center">{detectionParams.mlConfidenceThreshold}</span>
+                  </div>
+                  <p className="text-xs text-gray-500 mt-1">Higher values reduce false positives but may miss structures</p>
+                </div>
+                
+                <button
+                  className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
+                  onClick={() => {
+                    // Ensure analysis area is set if not already
+                    if (!analysisArea && imagePreview) {
+                      setAnalysisArea({
+                        x: 0,
+                        y: 0,
+                        width: 1,
+                        height: 1
+                      });
+                      // Small delay to ensure state is updated before analysis
+                      setTimeout(() => analyzeImage(), 100);
+                    } else {
+                      analyzeImage();
+                    }
+                  }}
+                  disabled={isAnalyzing || !imagePreview}
+                >
+                  {isAnalyzing ? 'Analyzing...' : 'Analyze Image'}
+                </button>
+              </div>
+            )}
+            
+            {/* Results tab */}
+            {activeTab === 'results' && analysisResult && (
+              <div>
+                <h2 className="text-lg font-semibold mb-3">Analysis Results</h2>
+                
+                <div className="bg-blue-50 p-4 rounded-lg mb-4">
+                  <div className="grid grid-cols-2 gap-4">
+                    <div className="text-center">
+                      <div className="text-3xl font-bold text-blue-600">{analysisResult.totalCount}</div>
+                      <div className="text-sm text-gray-600">Total Structures</div>
+                    </div>
+                    <div className="text-center">
+                      <div className="text-3xl font-bold text-blue-600">{analysisResult.structuresByType.dwellings}</div>
+                      <div className="text-sm text-gray-600">Dwellings</div>
+                    </div>
+                  </div>
+                  
+                  <div className="mt-4 pt-4 border-t border-blue-100">
+                    <div className="flex justify-between text-sm">
+                      <div>
+                        <span className="text-gray-600">Residential:</span>
+                        <span className="ml-1 font-medium">{analysisResult.structuresByType.residential}</span>
+                      </div>
+                      <div>
+                        <span className="text-gray-600">Commercial:</span>
+                        <span className="ml-1 font-medium">{analysisResult.structuresByType.commercial}</span>
+                      </div>
+                    </div>
+                  </div>
+                </div>
+                
+                <div className="mb-4">
+                  <h3 className="text-md font-semibold mb-2">Location Information</h3>
+                  <div className="bg-gray-50 p-3 rounded text-sm">
+                    <div className="grid grid-cols-2 gap-2">
+                      {analysisResult.metadata.municipality && (
+                        <>
+                          <div className="text-gray-600">Municipality:</div>
+                          <div>{analysisResult.metadata.municipality}</div>
+                        </>
+                      )}
+                      {analysisResult.metadata.suburb && (
+                        <>
+                          <div className="text-gray-600">Suburb:</div>
+                          <div>{analysisResult.metadata.suburb}</div>
+                        </>
+                      )}
+                    </div>
+                  </div>
+                </div>
+              </div>
+            )}
+          </div>
+        </div>
+        
+        {/* Right panel - Image viewer */}
+        <div className="lg:col-span-2">
+          <div className="bg-white rounded-lg shadow overflow-hidden">
+            {/* Image viewer header */}
+            <div className="p-3 border-b flex justify-between items-center">
+              <div>
+                <h2 className="font-semibold">Image Viewer</h2>
+              </div>
+              
+              {/* Visualization mode selector */}
+              {analysisResult && (
+                <div className="flex space-x-2">
+                  <button
+                    className={`px-2 py-1 text-xs rounded ${visualizationMode === 'standard' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800'}`}
+                    onClick={() => setVisualizationMode('standard')}
+                  >
+                    Standard
+                  </button>
+                  <button
+                    className={`px-2 py-1 text-xs rounded ${visualizationMode === 'heatmap' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800'}`}
+                    onClick={() => setVisualizationMode('heatmap')}
+                  >
+                    Density
+                  </button>
+                  <button
+                    className={`px-2 py-1 text-xs rounded ${visualizationMode === 'roofColor' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800'}`}
+                    onClick={() => setVisualizationMode('roofColor')}
+                  >
+                    Roof Colors
+                  </button>
+                </div>
+              )}
+              
+              {/* Zoom controls */}
+              <div className="flex items-center space-x-2">
+                <button
+                  className="p-1 rounded hover:bg-gray-100"
+                  onClick={handleZoomOut}
+                >
+                  <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
+                  </svg>
+                </button>
+                <span className="text-sm text-gray-600">{Math.round(zoomLevel * 100)}%</span>
+                <button
+                  className="p-1 rounded hover:bg-gray-100"
+                  onClick={handleZoomIn}
+                >
+                  <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
+                  </svg>
+                </button>
+                <button
+                  className="p-1 rounded hover:bg-gray-100"
+                  onClick={handleZoomReset}
+                >
+                  <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
+                  </svg>
+                </button>
+              </div>
+            </div>
+            
+            {/* Image container */}
+            <div className="relative overflow-hidden" style={{ height: '500px' }}>
+              {imagePreview ? (
+                <div
+                  ref={imageContainerRef}
+                  className="relative w-full h-full overflow-hidden"
+                >
+                  <div
+                    className="absolute top-0 left-0 w-full h-full transition-transform duration-100"
+                    style={{
+                      transform: `scale(${zoomLevel}) translate(${panPosition.x / zoomLevel}px, ${panPosition.y / zoomLevel}px)`,
+                      transformOrigin: 'center center'
+                    }}
+                  >
+                    {/* The image */}
+                    <img
+                      src={imagePreview}
+                      alt="Satellite imagery"
+                      className="w-full h-full object-contain"
+                    />
+                    
+                    {/* Analysis results overlay */}
+                    {analysisResult && visualizationMode === 'standard' && analysisResult.structures.map((structure) => (
+                      <div
+                        key={structure.id}
+                        className="absolute rounded-sm"
+                        style={{
+                          left: `${structure.boundingBox.x}%`,
+                          top: `${structure.boundingBox.y}%`,
+                          width: `${structure.boundingBox.width}%`,
+                          height: `${structure.boundingBox.height}%`,
+                          backgroundColor: structure.type === 'residential' ? 
+                            (structure.isDwelling ? 'rgba(37, 99, 235, 0.2)' : 'rgba(96, 165, 250, 0.3)') : 
+                            'rgba(34, 197, 94, 0.3)',
+                          border: structure.isDwelling ? 
+                            '2px solid rgba(37, 99, 235, 0.8)' : 
+                            '1px solid rgba(96, 165, 250, 0.5)'
+                        }}
+                      />
+                    ))}
+                  </div>
+                </div>
+              ) : (
+                <div className="flex items-center justify-center h-full bg-gray-100">
+                  <p className="text-gray-500">Upload an image to begin analysis</p>
+                </div>
+              )}
+              
+              {/* Loading overlay */}
+              {isAnalyzing && (
+                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center">
+                  <div className="bg-white p-6 rounded-lg shadow-lg text-center">
+                    <div className="inline-block animate-spin rounded-full h-12 w-12 border-4 border-gray-300 border-t-blue-600 mb-4"></div>
+                    <p className="text-lg font-medium">Analyzing Image</p>
+                    <p className="text-sm text-gray-600 mt-1">Detecting structures and calculating metrics...</p>
+                  </div>
+                </div>
+              )}
+              
+              {/* Paste success notification */}
+              {pasteSuccess && !isAnalyzing && (
+                <div className="absolute top-4 right-4 bg-green-50 text-green-700 p-3 rounded-md shadow-md flex items-center z-10">
+                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
+                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
+                  </svg>
+                  <span>Screenshot successfully pasted!</span>
+                </div>
+              )}
+            </div>
+          </div>
+        </div>
+      </div>
+    </div>
+  );
+}
-- 
2.49.0.windows.1

